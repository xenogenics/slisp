# x86-64 assembly generation guideline

## Simple bytecode example
```
fib:
    0000 Rot(2)
    0001 Psh(Number(1))
    0002 Get(2)
    0003 Le
    0004 Brn(3)
    0005 Get(1)
    0006 Br(12)
    0007 Psh(Number(2))
    0008 Get(2)
    0009 Sub
    0010 Psh(Funcall(0, Some(1)))
    0011 Call(1)
    0012 Psh(Number(1))
    0013 Get(3)
    0014 Sub
    0015 Psh(Funcall(0, Some(1)))
    0016 Call(1)
    0017 Add
    0018 Rot(2)
    0019 Pop(1)
    0020 Ret
main:
    0021 Psh(Number(30))
    0022 Psh(Funcall(0, Some(1)))
    0023 Call(1)
    0024 Ret
```
## x86 call/return protocol

* The stack layout on a call looks exactly like what we have in the machine.
* We need to rotate the arguments and the return address.

## Stack values considerations

* Stack values in the VM are 24B: 8 for the discriminant and 16 for the value
  (due to the Pair having two words).
* When pushing a value on the stack, we first need to grow the stack by 16B.
  Then, we need to initialize the discriminant. Finally, we need to copy the
  value:
  ```
  sub 16, %esp
  movl DISCRIMINANT, -16(%esp)
  movl VALUE, -8(%esp)
  ```
* Care need to be taken when assigning reference-counted stack values.

## Stack values discriminants

| Immediate | Discriminant |
|-----------|--------------|
| Nil       | 0x0          |
| True      | 0x1          |
| Char      | 0x2          |
| Number    | 0x3          |
| Extcall   | 0x4          |
| Funcall   | 0x5          |
| Wildcard  | 0x6          |

| Value     | Discriminant |
|-----------|--------------|
| Byte      | 0xA          |
| Closure   | 0xB          |
| Link      | 0xC          |
| Pair      | 0xD          |
| String    | 0xE          |
| Symbol    | 0xF          |

## Implementation of the fibonacci example
```gas
.section .text
.global _start

_start:
    # Clear base pointer
    xor %ebp, %ebp
    # Align the stack to 16B
    and $0xffffffffffffff00,%rsp
    # Push the link header
    pushq $0xC
    # Call main
    call main
    # Remove the link header
    add $8, %rsp
    # sys_exit(0)
    xor %rdi, %rdi
    movq $60, %rax
    syscall

main:
    # Push(Number(30))
    pushq $0x2
    pushq $32
    # Push(Funcall(..)) -> simplified as 'call' if the arity match
    pushq $0xC
    call fib
    add $8, %rsp
    # Put the result in %rax
    popq %rax
    add $8, %rsp
    ret

fib:
    # Rot(2) - AVX
    vmovdqu (%rsp), %ymm0
    vperm2f128 $0x1, %ymm0, %ymm0, %ymm0
    vmovdqu %ymm0, (%rsp)
    # Psh(Number(1))
    pushq $0x2
    pushq $1
    # Get(2)
    pushq (2*16-8)(%rsp)
    pushq (2*16-8)(%rsp)
    # Le
    movq 16(%rsp), %rax
    movq (%rsp), %rdx
    add $32, %rsp
    cmp %rax, %rdx
    jle _000
    pushq $0x0
    pushq $0
    jmp _001
_000:
    pushq $0x1
    pushq $0
_001:
    # Brn
    movq 8(%rsp), %rax
    movq $0, %rdx
    add $16, %rsp
    cmp %rax, %rdx
    je _002
    # Get(1)
    pushq (1*16-8)(%rsp)
    pushq (1*16-8)(%rsp)
    # Br(12)
    jmp _003
_002:
    # Psh(Number(2))
    pushq $0x2
    pushq $2
    # Get(2)
    pushq (2*16-8)(%rsp)
    pushq (2*16-8)(%rsp)
    # Sub
    movq 16(%rsp), %rax
    movq (%rsp), %rdx
    add $32, %rsp
    sub %rax, %rdx
    pushq $0x2
    pushq %rdx
    # Psh(Funcall(..)) + Call(..)
    pushq $0xC
    call fib
    add $8, %rsp
    # Psh(Number(1))
    pushq $0x2
    pushq $1
    # Get(3)
    pushq (3*16-8)(%rsp)
    pushq (3*16-8)(%rsp)
    # Sub
    movq 16(%rsp), %rax
    movq (%rsp), %rdx
    add $32, %rsp
    sub %rax, %rdx
    pushq $0x2
    pushq %rdx
    # Psh(Funcall(..)) + Call(..)
    pushq $0xC
    call fib
    add $8, %rsp
    # Add
    movq 16(%rsp), %rax
    movq (%rsp), %rdx
    add $32, %rsp
    addq %rax, %rdx
    pushq $0x2
    pushq %rdx
_003:
     # Rot(2)
     vmovdqu (%rsp), %ymm0
     vperm2f128 $0x1, %ymm0, %ymm0, %ymm0
     vmovdqu %ymm0, (%rsp)
     # Pop(1)
     add $16, %rsp
     # Extra Rot(2) for the link 
     vmovdqu (%rsp), %ymm0
     vperm2f128 $0x1, %ymm0, %ymm0, %ymm0
     vmovdqu %ymm0, (%rsp)
     # Ret
    ret
```
