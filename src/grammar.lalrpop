use std::rc::Rc;

use lalrpop_util::ParseError;

use crate::atom::{Atom, Span};
use crate::compiler::CompilerTrait;

grammar<C>(compiler: &mut C) where C: CompilerTrait;

extern {
  type Error = crate::error::Error;
}

match {
	"(", ")", ".", "`", "'", ",", ",@", "~",
	r"\^([!-\[]|[\]-~]|\\\\|\\e|\\n|\\r|\\t)" => Char,
	r"-?[0-9]+" => Number,
	r"x[0-9A-F]+" => HexNumber,
	r#""([^"\\]|\\["\\0\\e\\n\\r\\t])*""# => String,
	"nil" => Nil,
	"T" => True,
	"_" => Wildcard,
	r"\s*" => {},
	r";[^\n]*" => {},
} else {
	r"([a-zA-Z]|[!@$%&*_+\-={}\[\]:#|\\<>?/])([a-zA-Z0-9]|[!@$%&*_+\-={}\[\]:#|\\<>?,/]){0,14}" => Symbol,
}

pub Lists: Vec<Rc<Atom>> = {
	<e:List> =>? {
		compiler.load(e.clone())?;
		Ok(vec![e])
	},
	<mut a:Lists> <b:List> =>? {
		compiler.load(b.clone())?;
		a.push(b); 
		Ok(a)
	}
}

List: Rc<Atom> = {
	<start:@L> "(" ")" <end:@R> => {
		Atom::nil().with_span(Span::Offset(start, end))
	},
	<start:@L> "(" <v:Terms> ")" <end:@R> => {
		v.with_span(Span::Offset(start, end))
	},
	<start:@L> "(" <v:Terms> "." <w:UnquotedTerm> ")" <end:@R> => {
		Atom::conc(v, w).with_span(Span::Offset(start, end))
	},
}

Terms: Rc<Atom> = {
	"~" <e:Term> =>? {
		let comp = compiler.clone();
		comp.eval(e).map_err(|error| ParseError::User { error })
	},
	"~" <e:Term> <v:Terms> =>? {
		let comp = compiler.clone();
		let expr = compiler.clone().eval(e).map_err(|error| ParseError::User { error })?;
		Ok(Atom::conc(expr, v))
	},
	<start:@L> <e:UnquotedTerm> <end:@R> => {
		Atom::cons(e, Atom::nil()).with_span(Span::Offset(start, end))
	},
	<start:@L> <e:UnquotedTerm> <v:Terms> <end:@R> => {
		Atom::cons(e, v).with_span(Span::Offset(start, end))
	},
}

UnquotedTerm: Rc<Atom> = {
	<start:@L> ","  <e:Term> <end:@R> => {
		Atom::cons(Atom::symbol("unquote"), e).with_span(Span::Offset(start, end))
	},
	<start:@L> ",@" <e:Term> <end:@R> => {
		Atom::cons(Atom::symbol("unquote-splice"), e).with_span(Span::Offset(start, end))
	},
	<e:Term> => e,
}

Term: Rc<Atom> = {
	<start:@L> "`" <e:Atom> <end:@R> => {
		Atom::cons(Atom::symbol("backquote"), e).with_span(Span::Offset(start, end))
	},
	<start:@L> "'" <e:Atom> <end:@R> => {
		Atom::cons(Atom::symbol("quote"), e).with_span(Span::Offset(start, end))
	},
	<e:Atom> => e,
}

Atom: Rc<Atom> = {
	<e:List>                         => e,
	<start:@R> <e:Terminal> <end:@R> => e.with_span(Span::Offset(start, end)),
}

Terminal: Rc<Atom> = {
	Char      => Atom::char(<>.as_bytes()[1]),
	Number    => Atom::number(<>.parse().unwrap()),
	HexNumber => Atom::number(i64::from_str_radix(&<>[1..], 16).unwrap()), 
	String    => Atom::string(<>),
	Symbol    => Atom::symbol(<>),
	Nil       => Atom::nil(),
	True      => Atom::t(),
	Wildcard  => Atom::wildcard(),
}
