use std::rc::Rc;

use lalrpop_util::ParseError;

use crate::atom::{Atom, Span};
use crate::compiler::CompilerTrait;

grammar<C>(compiler: &mut C) where C: CompilerTrait;

extern {
  type Error = crate::error::Error;
}

match {
	"(", ")", ".", "`", "'", ",", ",@", "~",
	r"\^([!-\[]|[\]-~]|\\\\|\\e|\\n|\\r|\\s|\\t)" => Char,
	r"-?[0-9]+" => Number,
	r"x[0-9A-F]+" => HexNumber,
	r#""([^"\\]|\\["\\0\\e\\n\\r\\t])*""# => String,
	"nil" => Nil,
	"T" => True,
	"_" => Wildcard,
	r"\s*" => {},
	r";[^\n]*" => {},
} else {
	r"([a-zA-Z]|[!@$%&*_+\-={}\[\]:#|\\<>?/])([a-zA-Z0-9]|[!@$%&*_+\-={}\[\]:#|\\<>?,/]){0,14}" => Symbol,
}

pub Lists: Vec<Rc<Atom>> = {
	<e:List> =>? {
		compiler.load(e.clone())?;
		Ok(vec![e])
	},
	<mut a:Lists> <b:List> =>? {
		compiler.load(b.clone())?;
		a.push(b); 
		Ok(a)
	}
}

pub Expression: Rc<Atom> = {
	<start:@L> "~" <e:Atom> <end:@R> =>? {
		let comp = compiler.clone();
		let rslt = comp.eval(e, 1024, false).map_err(|error| ParseError::User { error })?;
		Ok(rslt.with_span(Span::Offset(start, end)))
	},
	<start:@L> "'"  <e:Atom> <end:@R> => {
		Atom::cons(Atom::symbol("quote"), e).with_span(Span::Offset(start, end))
	},
	<start:@L> "`" <e:Atom> <end:@R> => {
		Atom::cons(Atom::symbol("backquote"), e).with_span(Span::Offset(start, end))
	},
	<start:@L> "," <e:Atom> <end:@R> => {
		Atom::cons(Atom::symbol("unquote"), e).with_span(Span::Offset(start, end))
	},
	<start:@L> ",@" <e:Atom> <end:@R> => {
		Atom::cons(Atom::symbol("unquote-splice"), e).with_span(Span::Offset(start, end))
	},
	<start:@L> <e:Atom> <end:@R> => {
		e.with_span(Span::Offset(start, end))
	},
}

Expressions: Rc<Atom> = {
	<start:@L> <e:Expression> <end:@R> => {
		Atom::cons(e, Atom::nil()).with_span(Span::Offset(start, end))
	},
	<start:@L> <e:Expression> <v:Expressions> <end:@R> => {
		Atom::cons(e, v).with_span(Span::Offset(start, end))
	},
}

Atom: Rc<Atom> = {
	<e:List> => e,
	<start:@R> <e:Terminal> <end:@R> => e.with_span(Span::Offset(start, end)),
}

List: Rc<Atom> = {
	<start:@L> "(" ")" <end:@R> => {
		Atom::nil().with_span(Span::Offset(start, end))
	},
	<start:@L> "(" <v:Expressions> ")" <end:@R> => {
		v.with_span(Span::Offset(start, end))
	},
	<start:@L> "(" <v:Expressions> "." <w:Expression> ")" <end:@R> => {
		Atom::conc(v, w).with_span(Span::Offset(start, end))
	},
}

Terminal: Rc<Atom> = {
	Char      => {
	  let mut chars = <>[1..].chars();
	  Atom::char(Atom::next_char(&mut chars).unwrap() as u8)
	},
	Number    => Atom::number(<>.parse().unwrap()),
	HexNumber => Atom::number(i64::from_str_radix(&<>[1..], 16).unwrap()), 
	String    => Atom::string(<>),
	Symbol    => Atom::symbol(<>),
	Nil       => Atom::nil(),
	True      => Atom::t(),
	Wildcard  => Atom::wildcard(),
}
