use std::rc::Rc;

use lalrpop_util::ParseError;

use crate::atom::Atom;
use crate::compiler::CompilerTrait;

grammar<C>(compiler: &mut C) where C: CompilerTrait;

extern {
  type Error = crate::error::Error;
}

match {
	"(", ")", ".", "`", "'", ",", ",@", "~",
	r"\^([!-\[]|[\]-~]|\\\\|\\e|\\n|\\r|\\t)" => Char,
	r"-?[0-9]+" => Number,
	r"x[0-9A-F]+" => HexNumber,
	r#""([^"\\]|\\["\\0\\e\\n\\r\\t])*""# => String,
	"nil" => Nil,
	"T" => True,
	"_" => Wildcard,
	r"\s*" => {},
	r";[^\n]*" => {},
} else {
	r"([a-zA-Z]|[!@$%&*_+\-={}\[\]:#|\\<>?/])([a-zA-Z0-9]|[!@$%&*_+\-={}\[\]:#|\\<>?,/]){0,14}" => Symbol,
}

pub Lists: Vec<Rc<Atom>> = {
	<e:List> =>? {
		compiler.load(e.clone())?;
		Ok(vec![e])
	},
	<mut a:Lists> <b:List> =>? {
		compiler.load(b.clone())?;
		a.push(b); 
		Ok(a)
	}
}

List: Rc<Atom> = {
	"(" ")"                                => Atom::nil(),
	"(" <v:Terms> ")"                      => v,
	"(" <v:Terms> "." <w:UnquotedTerm> ")" => Atom::conc(v, w),
}

Terms: Rc<Atom> = {
	"~" <e:Term> =>? {
		let comp = compiler.clone();
		comp.eval(e).map_err(|error| ParseError::User { error })
	},
	"~" <e:Term> <v:Terms> =>? {
		let comp = compiler.clone();
		let expr = compiler.clone().eval(e).map_err(|error| ParseError::User { error })?;
		Ok(Atom::conc(expr, v))
	},
    <e:UnquotedTerm>           => Atom::cons(e, Atom::nil()),
    <e:UnquotedTerm> <v:Terms> => Atom::cons(e, v),
}

UnquotedTerm: Rc<Atom> = {
	","  <e:Term> => Atom::cons(Atom::symbol("unquote"), e),
	",@" <e:Term> => Atom::cons(Atom::symbol("unquote-splice"), e),
		 <e:Term> => e,
}

Term: Rc<Atom> = {
	"`" <e:Atom> => Atom::cons(Atom::symbol("backquote"), e),
	"'" <e:Atom> => Atom::cons(Atom::symbol("quote"), e),
		<e:Atom> => e,
}

Atom: Rc<Atom> = {
	<e:List>     => e,
	<e:Terminal> => e,
}

Terminal: Rc<Atom> = {
	Char      => Atom::char(<>.as_bytes()[1]),
	Number    => Atom::number(<>.parse().unwrap()),
	HexNumber => Atom::number(i64::from_str_radix(&<>[1..], 16).unwrap()), 
	String    => Atom::string(<>),
	Symbol    => Atom::symbol(<>),
	Nil       => Atom::nil(),
	True      => Atom::t(),
	Wildcard  => Atom::wildcard(),
}
